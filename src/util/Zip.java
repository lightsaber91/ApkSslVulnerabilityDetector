package util;

import xmlApkParser.*;
import org.xmlpull.v1.*;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * 
 * @author Simone Martucci
 * @author Mattia Mancini
 * 
 */
public class Zip {

	private static final String DEFAULT_XML = "AndroidManifest.xml";
	private static final String DEFAULT_DEX = "classes.dex";
    public static final String PREFIX = "classes";
    public static final String SUFFIX = ".dex";
    
	private ZipFile file = null;
	private String packageName = null;
	private boolean internet = false;
	private InputStream xmlManifest;
	private String version = null;
	
	public Zip(String apkPath) throws IOException, ParserConfigurationException, SAXException {
        StringBuilder xmlSb = new StringBuilder(100);
        try {
                File apkFile = new File(apkPath);
                if(!apkFile.exists()) {
                	System.out.println("File does not exists, please insert something correct!");
                	System.exit(1);
                }
                file = new ZipFile(apkFile, ZipFile.OPEN_READ);
                ZipEntry entry = file.getEntry(DEFAULT_XML);
                
                AXmlResourceParser parser=new AXmlResourceParser();
                parser.open(file.getInputStream(entry));
                
                StringBuilder sb = new StringBuilder(10);
                final String indentStep="       ";
                
                int type;
                while ((type=parser.next()) != XmlPullParser.END_DOCUMENT) {
                        switch (type) {
                                case XmlPullParser.START_DOCUMENT:
                                {
                                        log(xmlSb,"<?xml version=\"1.0\" encoding=\"utf-8\"?>");
                                        break;
                                }
                                case XmlPullParser.START_TAG:
                                {
                                        log(false,xmlSb,"%s<%s%s",sb,getNamespacePrefix(parser.getPrefix()),parser.getName());
                                        sb.append(indentStep);
                                        
                                        int namespaceCountBefore=parser.getNamespaceCount(parser.getDepth()-1);
                                        int namespaceCount=parser.getNamespaceCount(parser.getDepth());
                                        
                                        for (int i=namespaceCountBefore;i!=namespaceCount;++i) {
                                                log(xmlSb,"%sxmlns:%s=\"%s\"",i==namespaceCountBefore?"  ":sb,parser.getNamespacePrefix(i),parser.getNamespaceUri(i));
                                        }
                                        
                                        for (int i=0,size=parser.getAttributeCount();i!=size;++i) {
                                                log(false,xmlSb, "%s%s%s=\"%s\""," ",getNamespacePrefix(parser.getAttributePrefix(i)),parser.getAttributeName(i),getAttributeValue(parser,i));
                                        }
                                        log(xmlSb,">");
                                        break;
                                }
                                case XmlPullParser.END_TAG:
                                {
                                        sb.setLength(sb.length()-indentStep.length());
                                        log(xmlSb,"%s</%s%s>",sb,getNamespacePrefix(parser.getPrefix()),parser.getName());
                                        break;
                                }
                                case XmlPullParser.TEXT:
                                {
                                        log(xmlSb,"%s%s",sb,parser.getText());
                                        break;
                                }
                        }
                }
                parser.close();
        }
        catch (Exception e) {
                e.printStackTrace();
        }
        xmlManifest = new ByteArrayInputStream(xmlSb.toString().getBytes());
        setManifestOption(xmlManifest);
        
}
	
	public File getDexFile() throws IOException {
        ZipEntry entry = file.getEntry(DEFAULT_DEX);
    	InputStream in = file.getInputStream(entry);
        final File tempFile = File.createTempFile(PREFIX, SUFFIX);
        tempFile.deleteOnExit();
        try (FileOutputStream out = new FileOutputStream(tempFile)) {
        	byte[] buffer = new byte[1024];
        	int len = in.read(buffer);
        	while (len != -1) {
        	    out.write(buffer, 0, len);
        	    len = in.read(buffer);
        	}
        }
        return tempFile;
    }
 
	private void setManifestOption(InputStream xml) throws ParserConfigurationException, SAXException, IOException {
	    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
        // create a new document from input stream
        Document doc = builder.parse(xml);

        // get the first element
        Element element = doc.getDocumentElement();
        packageName = element.getAttribute("package");
        version = element.getAttribute("android:versionName");
        // get all child nodes
        NodeList nodes = element.getElementsByTagName("uses-permission");
        for (int temp = 0; temp < nodes.getLength(); temp++) {
        	 
    		Node nNode = nodes.item(temp);  
    		Element eElement = (Element) nNode;
    		if(eElement.getAttribute("android:name").equals("android.permission.INTERNET"))
    			internet = true;
    	}
        
	}

	public String getPackageName() {
		return packageName;
	}
	
	public String getPackageVersion() {
		return version;
	}
	
	public boolean getInternetPermission() {
		return internet;
	}


	public void close() throws IOException {
		file.close();
	}
	
    private static void log(StringBuilder xmlSb,String format,Object...arguments) {
        log(true,xmlSb, format, arguments);
    }

    private static void log(boolean newLine,StringBuilder xmlSb,String format,Object...arguments) {
        xmlSb.append(String.format(format, arguments));
        if(newLine) xmlSb.append("\n");
    }

    private static String getNamespacePrefix(String prefix) {
        if (prefix==null || prefix.length()==0) {
                return "";
        }
        return prefix+":";
    }

    private static String getAttributeValue(AXmlResourceParser parser,int index) {
        int type=parser.getAttributeValueType(index);
        int data=parser.getAttributeValueData(index);
        if (type==TypedValue.TYPE_STRING) {
                return parser.getAttributeValue(index);
        }
        if (type==TypedValue.TYPE_ATTRIBUTE) {
                return String.format("?%s%08X",getPackage(data),data);
        }
        if (type==TypedValue.TYPE_REFERENCE) {
                return String.format("@%s%08X",getPackage(data),data);
        }
        if (type==TypedValue.TYPE_FLOAT) {
                return String.valueOf(Float.intBitsToFloat(data));
        }
        if (type==TypedValue.TYPE_INT_HEX) {
                return String.format("0x%08X",data);
        }
        if (type==TypedValue.TYPE_INT_BOOLEAN) {
                return data!=0?"true":"false";
        }
        if (type==TypedValue.TYPE_DIMENSION) {
                return Float.toString(complexToFloat(data))+ DIMENSION_UNITS[data & TypedValue.COMPLEX_UNIT_MASK];
        }
        if (type==TypedValue.TYPE_FRACTION) {
                return Float.toString(complexToFloat(data))+ FRACTION_UNITS[data & TypedValue.COMPLEX_UNIT_MASK];
        }
        if (type>=TypedValue.TYPE_FIRST_COLOR_INT && type<=TypedValue.TYPE_LAST_COLOR_INT) {
                return String.format("#%08X",data);
        }
        if (type>=TypedValue.TYPE_FIRST_INT && type<=TypedValue.TYPE_LAST_INT) {
                return String.valueOf(data);
        }
        return String.format("<0x%X, type 0x%02X>",data,type);
    }

    private static String getPackage(int id) {
        if (id>>>24==1) {
                return "android:";
        }
        return "";
    }
 
    public static float complexToFloat(int complex) {
        return (float)(complex & 0xFFFFFF00)*RADIX_MULTS[(complex>>4) & 3];
	}
	
	private static final float RADIX_MULTS[]={
	        0.00390625F,3.051758E-005F,1.192093E-007F,4.656613E-010F
	};
	private static final String DIMENSION_UNITS[]={
	        "px","dip","sp","pt","in","mm","",""
	};
	private static final String FRACTION_UNITS[]={
	        "%","%p","","","","","",""
	};
    
}
