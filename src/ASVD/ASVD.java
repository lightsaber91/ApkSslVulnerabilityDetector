package ASVD;

import java.io.IOException;
import java.util.List;

import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.SAXException;
import org.xmlpull.v1.XmlPullParserException;

import analysis.*;
/**
 * 
 * @author Simone Martucci
 * @author Mattia Mancini
 * 
 */
public final class ASVD {
	/**
	 * @param apkName: name of the file, read from command line
	 * @param xmlOutput: if true output will be formatted with xml syntax
	 * @param decompilerDirectory: directory where to store bytecode for analysis
	 * @param bytecode: object containing bytecode
	 * @param showOnlyApkInfo: print just package name and version
	 * @param errors: container for all errors
	 */
	private static String apkName = null;
	private static boolean xmlOutput = false;
	private static String decompilerDirectory = null;
	private static DalvikAnalisys bytecode = null;
	private static boolean showOnlyApkInfo = false;
	private static ErrorLists errors;
	
	public static void main(String[] args) throws IOException, ParserConfigurationException, SAXException, XmlPullParserException {
		//read passed arguments
		parseArgs(args);
		if (apkName == null) {
			//print help
			printHelp();
		}
		//create new apk file
		APK file = new APK(apkName);
		System.out.println("Analize file: " + apkName);
		System.out.println("Package: " + file.getPackage() + ", Version: " + file.getVersion());
		//check file permission
		if(!file.getPermssion()) {
			//if file does not require internet access do not continue analysis
			System.out.println("App does not require INTERNET permission. No need to worry about SSL misuse... Abort!\n");
			file.close();
			System.exit(0);
		}
		if(showOnlyApkInfo) {
			file.close();
			System.exit(0);
		}
		//internet permission found so continue analysis
		System.out.println("INTERNET permission found, continue analysis...");
		
		//new dex file will be created to read the bytecode correctly
		errors = new ErrorLists();
		bytecode = new DalvikAnalisys(file.getDexFile(), file.getPackage(), decompilerDirectory, errors);
		System.out.println("Decompilation of dex file finished");
		
		//beginning of real analysis on the dex file
		long startTime = System.currentTimeMillis();
		System.out.println("Beginning of analisys");
		bytecode.checkVulnerabilities();
		long estimatedTime = System.currentTimeMillis() - startTime;
		System.out.println("File analisys complete in " + estimatedTime/60 +" seconds!\n");
		
		if(xmlOutput) {
			//Print output in xml file
			printXml();
		}
		else {
			//print normal output
			printConclusion();
		}
		
		//close apk then exit
		file.close();
		System.out.println("Exiting...");
		System.exit(0);		
	}
	/**
	 * Print the output in xml format
	 */
	private static final void printXml() {
		//TODO
	}
	/**
	 * Print output in console standard output
	 */
	private static final void printConclusion() {
		System.out.println("Showing results:");
		List<String> classes = errors.getTmClass();
		if(classes.isEmpty())
			System.out.println("TrustManager Vulnerabilities Not Found!\n");
		else {
			System.out.println("TrustManager Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println(classes.get(i)+": ");
				System.out.println("	Client side: " + errors.getClientTmVulnerability().get(i));
				System.out.println("	Server side: " + errors.getServerTmVulnerability().get(i));
			}
			System.out.println();
		}
		classes = errors.getHnClass();
		if(classes.isEmpty()) 
			System.out.println("HostnameVerifier Vulnerabilities Not Found!\n");
		else {
			System.out.println("HostnameVerifier Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i)+": "+ errors.getHnVulnerability().get(i));
			}
			System.out.println();
		}
		classes = errors.getAllowedHnVerifier();
		if(classes.isEmpty()) 
			System.out.println("No ALLOW_ALL_HOSTNAME_VERIFIER found!\n");
		else {
			System.out.println("ALLOW_ALL_HOSTNAME_VERIFIER found in class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i));
			}
			System.out.println();
		}
		classes = errors.getSslhandleClass();
		if(classes.isEmpty())
			System.out.println("SslErrorHandler Vulnerabilities Not Found!\n");
		else {
			System.out.println("SslErrorHandler Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i)+": "+ errors.getSslhandleVulnerability().get(i));
			}
			System.out.println();
		}
	}
	/**
	 * Show a little guide to use this program
	 */
	private static final void printHelp() {
		System.out.println("Usage: asvd [-f APK] , [--file APK] : APK File to check");
		System.out.println("Options:");
		System.out.println("   [-d DIR] , [--dir DIR] : Store decompiled App's Java code for further analysis in dir");
		System.out.println("   [-x] , [--xml] : Print output as XML");
		System.out.println("   [-i] , [--info] : Print only APK info like package and version");
		System.exit(0);
	}
	
	/**
	 * Utility to read the arguments in the correct way
	 * @param args : arguments passed
	 */
	private static void parseArgs(String[] args) {
		
		for(int i = 0; i < args.length; i++) {
			if(args[i].compareTo("-h") == 0 || args[i].compareTo("--help") == 0) {
				printHelp();
			}
			else if(args[i].compareTo("-x") == 0 || args[i].compareTo("--xml") == 0) xmlOutput = true;
			else if(args[i].compareTo("-d") == 0 || args[i].compareTo("--dir") == 0) {
				if(i < args.length -1 && !args[i+1].startsWith("-"))
					decompilerDirectory = args[i+1];
			}
			else if(args[i].compareTo("-f") == 0 || args[i].compareTo("--file") == 0) {
				if(i < args.length -1 && !args[i+1].startsWith("-"))
					apkName = args[i+1];
			}
			else if(args[i].compareTo("-i") == 0 || args[i].compareTo("--info") == 0) showOnlyApkInfo = true;
				
		}
		
	}


}
