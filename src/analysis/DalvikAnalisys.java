package analysis;

import org.jf.baksmali.*;

import util.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class DalvikAnalisys {
	
	private static String directory = null; 
	private static boolean tmpDir = true;
	private static File root = null;
//	private static boolean hvIsCalled = false;
	
	private static List<File> filelist = new ArrayList<File>();
	
	//Trust manager vulnerabilities variable
	private static List<String> tmClientVulnerable = new ArrayList<String>(); //vulnerabilit?? sul cerificato del client 
	private static List<String> tmServerVulnerable = new ArrayList<String>(); //vulnerabilit?? sul certificato del server
	private static List<String> tmFileName = new ArrayList<String>();  //file in cui si trova la vulerabilit??
	
	//HostnameVerifier vulnerabilities variable
	private static List<String> hnVulnerable = new ArrayList<String>();
	private static List<String> hnFileName = new ArrayList<String>();;
	
	public DalvikAnalisys(File dexClass, String packageName, String decompilerDir) throws IOException {
		
		//Set the correct directory to store the bytecode
		if(decompilerDir == null) 
			directory = System.getProperty("java.io.tmpdir")+"/smali/" + packageName; 
		else {
			directory = decompilerDir + "/" + packageName; 
			tmpDir = false;
		}
		root = new File(directory);

		//Start baksmali tool, convert dex that is not readable to smali, that is readable
		String[] smaliArgs = {"-o", directory, dexClass.getPath().toString()};
		main.main(smaliArgs);
		
	}
	
	/**
	 * This function is the core of all project
	 * Begin analysis of every smali file previously
	 * created and set the upper variable in case a 
	 * 
	 */
	public void checkVulnerabilities() {
		
		Smali.getSmaliFileList(root,filelist);
		for (File file : filelist) {
			try {
				BufferedReader reader = new BufferedReader(new FileReader(file));
				String line;
				boolean[] checked = {false , false, false};
				while ((line = reader.readLine()) != null) {
					if(line.contains(Const.SERVER_FUNCTION) && !checked[0]) {
						checked[0] = true;
						tmServerVulnerable.add(searchTmVulnerabilities(reader));
						tmFileName.add(file.getPath());
					}
					else if(line.contains(Const.CLIENT_FUNCTION) && !checked[1]) {
						checked[1] = true;
						tmClientVulnerable.add(searchTmVulnerabilities(reader));
					}
					else if(line.contains(Const.VERIFY) && line.contains(Const.INVOKE) && line.contains(Const.SSL_SESSION) && !checked[2]) {
							checked[2] = true;
							String callingClass = trim(line);
							String tmp = searchHnVulnerabilities(callingClass, filelist);
							if(tmp != null) {
								hnVulnerable.add(tmp);
							}
					}
				}
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		Smali.modifyPaths(tmFileName, hnFileName, directory);
		if(tmpDir) Smali.removeTmpFile(filelist, root);
		return;
	}
	
	private String trim(String line) {
		String[] tmp = line.split(";->");
		String[] toRet = tmp[0].split("/");
		return toRet[toRet.length -1];
	}
	
	private String searchHnVulnerabilities(String name, List<File> list) throws IOException {
		for(File file : list) {
			if(file.getName().contains(name)) {
				String line;
				BufferedReader reader = new BufferedReader(new FileReader(file));
				while((line = reader.readLine()) != null) {
					if(line.contains(Const.VERIFY) && line.contains(Const.METHOD) && line.contains(Const.SSL_SESSION)) {
						reader.mark(1000);
						while(!(line = reader.readLine()).equals(Const.END)) {
							if(line.contains(Const.INVOKE)) {
								hnFileName.add(file.getPath());
								reader.close();
								return Const.MAYBE;
							}
						}
						reader.reset();
						boolean defTrue = false;
						line = "";
						while(!(line = reader.readLine()).equals(Const.END)) {
							if(line.contains(Const.DEF_TRUE)) {
								defTrue = true;
							}
							if(line.contains(Const.RET_V0) && defTrue) {
								hnFileName.add(file.getPath());
								reader.close();
								return Const.VULNERABLE;
							}
						}
						reader.close();
						return Const.NOT_VULNERABLE;
					}
				}
				reader.close();
			}
		}
		return null;
	}
	
	private String searchTmVulnerabilities(BufferedReader reader) throws IOException {
		String line;
		while(!(line = reader.readLine()).equals(Const.END)) {
			if(line.contains(Const.INVOKE)) {
				return Const.MAYBE;
			}
			else if (line.contains(Const.VOID)) return Const.VULNERABLE;
		}
		return Const.NOT_VULNERABLE;
	}
	
	public List<String> getClientTmVulnerability() {
		return tmClientVulnerable;
	}
	
	public List<String> getServerTmVulnerability() {
		return tmServerVulnerable;
	}
	
	public List<String> getTmClass(){
		return tmFileName;
	}
	
	public List<String> getHnVulnerability() {
		return hnVulnerable;
	}
	
	public List<String> getHnClass(){
		return hnFileName;
	}
	
}
