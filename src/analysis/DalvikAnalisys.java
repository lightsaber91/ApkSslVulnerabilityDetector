package analysis;

import org.jf.baksmali.*;

import util.*;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * 
 * @author Simone Martucci
 * @author Mattia Mancini
 *
 * Class used decompile dex file to smali files
 * and then analyze every one to search errors
 */

public class DalvikAnalisys {
	
	private static String directory = null; 
	private static boolean tmpDir = true;
	private static File root = null;
	private static List<File> filelist = new ArrayList<File>();
	private static ErrorLists el;
	
	public DalvikAnalisys(File dexClass, String packageName, String decompilerDir, ErrorLists errors) throws IOException {
		
		//Set the correct directory to store the bytecode
		if(decompilerDir == null) 
			directory = System.getProperty("java.io.tmpdir")+"/smali/" + packageName; 
		else {
			directory = decompilerDir + "/" + packageName; 
			tmpDir = false;
		}
		root = new File(directory);
		el = errors;
		//Start baksmali tool, convert dex that is not readable to smali, that is readable
		String[] smaliArgs = {"-o", directory, dexClass.getPath().toString()};
		main.main(smaliArgs);
		
	}
	
	/**
	 * This function is the core of all project
	 * Begin analysis of every smali file previously
	 * created and set the upper variable in case a 
	 */
	public void checkVulnerabilities() {
		//new analyzer will be created, need to check every file
		Analyzer analyzer = new Analyzer();
		//obtaining smali file list
		SmaliManager.getSmaliFileList(root,filelist);
		for (File file : filelist) {
			try {
				//buffered reader to read file one line at a time
				BufferedReader reader = new BufferedReader(new FileReader(file));
				String line;
				//array of boolean to avoid looking for the same vulnerability in a file many times 
				boolean[] checked = {false , false, false, false, false, false};
				//begin reading file
				while ((line = reader.readLine()) != null) {
					if(line.contains(Const.SERVER_FUNCTION) && !checked[0]) {
						checked[0] = true;
						el.setServerTmVulnerability(analyzer.searchTmVulnerabilities(reader));
						el.setTmClass(file.getPath());
					}
					else if(line.contains(Const.CLIENT_FUNCTION) && !checked[1]) {
						checked[1] = true;
						el.setClientTmVulnerability(analyzer.searchTmVulnerabilities(reader));
					}
					else if(line.contains(Const.VERIFY) && line.contains(Const.INVOKE) && line.contains(Const.SSL_SESSION) && !checked[2]) {
						checked[2] = true;
						String callingClass = trim(line);
						String tmp = analyzer.searchHnVulnerabilities(callingClass, filelist, null, el);
						if(tmp != null) {
							el.setHnVulnerability(tmp);
						}
					}
					else if(line.contains(Const.VERIFY) && line.contains(Const.SSL_SESSION) && !checked[3]) {
						checked[3] = true;
						el.setHnClass(file.getPath());
						el.setHnVulnerability(analyzer.searchHnVulnerabilities(null, null, reader, el));
					}
					else if(line.contains(Const.METHOD) && line.contains(Const.SSL_FUNCTION) && !checked[4]) {
						checked[4] = true;
						el.setSslhandleClass(file.getPath());
						el.setSslhandleVulnerability(analyzer.searchSslErrorVulnerabilities(reader));
					}
					else if(line.contains(Const.ALLOW_HOSTNAME) && !checked[5]) {
						checked[5] = true;
						el.setAllowedHnVerifier(file.getPath());
					}
				}
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		//modify list to get a more user friendly ouptut
		ListManager.removeCopies(el.getHnClass(), el.getHnVulnerability());
		ListManager.modifyPaths(el.getTmClass(), directory);
		ListManager.modifyPaths(el.getHnClass(), directory);
		ListManager.modifyPaths(el.getSslhandleClass(), directory);
		ListManager.modifyPaths(el.getAllowedHnVerifier(), directory);
		//remove files if not specified otherwise
		if(tmpDir) SmaliManager.removeTmpFile(filelist, root);
	}
	
	private String trim(String line) {
		//extract file name
		String[] tmp = line.split(";->");
		String[] toRet = tmp[0].split("/");
		return toRet[toRet.length -1];
	}
	

}
