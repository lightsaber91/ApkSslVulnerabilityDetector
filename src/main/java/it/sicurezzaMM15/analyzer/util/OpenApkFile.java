package it.sicurezzaMM15.analyzer.util;

import it.sicurezzaMM15.analyzer.org.xmlpull.v1.*;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * 
 * @author Simone Martucci
 * @author Mattia Mancini
 * 
 */
public class OpenApkFile {
    /**
     * @param file: the APK opened as ZIP File
     * @param packageName: name of package
     * @param internet: true if apk requires internet access
     * @param xmlManifest: readable version of manifest
     * @param version version of apk
     */
	private ZipFile file = null;
	private String packageName = null;
	private boolean internet = false;
	private InputStream xmlManifest;
	private String version = null;
	private Document doc = null;
	/**
	 * Creates a new ZipFile containing every files in APK
	 * 
	 * @param apkPath: location of the app
	 * @throws IOException
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * 
	 */
	public OpenApkFile(String apkPath) throws IOException, ParserConfigurationException, SAXException {
        File apkFile = new File(apkPath);
        if(!apkFile.exists()) {
        	System.out.println("File does not exists, please insert something correct!");
        	return;
        }
        file = new ZipFile(apkFile, ZipFile.OPEN_READ);
	}
	
	/**
	 * This function search the correct entry in the zip file
	 * then use the parser to convert the manifest from binary to string
	 * 
	 * @throws IOException
	 * @throws XmlPullParserException
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 */
	public void ReadManifest() throws IOException, XmlPullParserException, ParserConfigurationException, SAXException {
    	ZipEntry entry = file.getEntry(Const.DEFAULT_XML);
        xmlManifest = XmlParser.manifestParser(file, entry);
        setManifestOption(xmlManifest);
	}

	/**
	 * Search the "classes.dex" file inside the zip and return it
	 * 
	 * @throws IOException
	 */
	public File getDexFile() throws IOException {
        ZipEntry entry = file.getEntry(Const.DEFAULT_DEX);
    	InputStream in = file.getInputStream(entry);
        final File tempFile = File.createTempFile(Const.PREFIX, Const.SUFFIX);
        tempFile.deleteOnExit();
        try (FileOutputStream out = new FileOutputStream(tempFile)) {
        	byte[] buffer = new byte[1024];
        	int len = in.read(buffer);
        	while (len != -1) {
        	    out.write(buffer, 0, len);
        	    len = in.read(buffer);
        	}
        }
        return tempFile;
    }
 
	/**
	 * Check package name, version and internet permission 
	 * info contained in Manfiest
	 * 
	 * @param xml: the xml manifest obtained before
	 * @throws ParserConfigurationException
	 * @throws SAXException
	 * @throws IOException
	 */
	private void setManifestOption(InputStream xml) throws ParserConfigurationException, SAXException, IOException {

	    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
        // create a new document from input stream
		doc = builder.parse(xml);
        // get the first element
        Element element = doc.getDocumentElement();
        packageName = element.getAttribute(Const.ATTRIBUTE_PKG);
        version = element.getAttribute(Const.ATTRIBUTE_VERSION);
        // get all child nodes
        NodeList nodes = element.getElementsByTagName(Const.USES_PERMISSION);
        for (int temp = 0; temp < nodes.getLength(); temp++) { 
    		Node nNode = nodes.item(temp);  
    		Element eElement = (Element) nNode;
    		if(eElement.getAttribute(Const.ATTRIBUTE_NAME).equals(Const.INTERNET_P))
    			internet = true;
        }
	}
	/**
	 * @return name of the package
	 */
	public String getPackageName() {
		return packageName;
	}
	
	/**
	 * @return version of the app
	 */
	public String getPackageVersion() {
		return version;
	}
	
	/**
	 * @return if app requires internet permission or not
	 */
	public boolean getInternetPermission() {
		return internet;
	}
	/**
	 * Close opened file
	 * @throws IOException
	 */
	public void close() throws IOException {
		file.close();
	}

	public Document getManifest() {
		return doc;
	}
    
}
