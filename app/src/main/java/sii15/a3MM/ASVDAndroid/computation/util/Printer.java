package sii15.a3MM.ASVDAndroid.computation.util;

import java.io.File;
import java.util.List;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import sii15.a3MM.ASVDAndroid.computation.malScanner.mScanner;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import sii15.a3MM.ASVDAndroid.computation.analysis.ErrorLists;

public class Printer {

	private static mScanner scanner = null;
	private static ErrorLists errors = null;
	/**
	 * Show a little guide to use this program
	 */
	public static final void printHelp() {
		System.out.println("Usage: asvd [-f APK] , [--file APK] : APK File to check");
		System.out.println("Options:");
		System.out.println("   [-d DIR] , [--dir DIR] : Store decompiled App's Java code for further analysis in dir");
		System.out.println("   [-x] , [--xml] : Print output as XML");
		System.out.println("   [-i] , [--info] : Print only APK info like package and version");
		System.out.println("   [-s] , [--scan] : Scan the APK to search malaware");
		System.exit(0);
	}
	
	/**
	 * Print the output in xml format and save to disk
	 */
	public static final void printXml(String pk, String version, String dir) {
		scanner = mScanner.getInstance();
		errors = ErrorLists.getInstance();
		try {
			DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
			DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
			// root elements
			Document doc = docBuilder.newDocument();
			Element rootElement = doc.createElement("result");
			doc.appendChild(rootElement);
			// set attribute to root element
			rootElement.setAttribute("package", pk);
			rootElement.setAttribute("version", version);
			// trust manager elements
			Element tm = doc.createElement("TrustManagers");
			rootElement.appendChild(tm);
			//Add every trust manager errors
			List<String> classes = errors.getTmClass();
			if(!classes.isEmpty()) {
				for(int i = 0; i < classes.size(); i++) {
					Element vul = doc.createElement("vulnerability");
					tm.appendChild(vul);
					vul.setAttribute("class", classes.get(i));
					vul.setAttribute("status", errors.getTmVulnerability().get(i));
				}
			}
			Element hn = doc.createElement("HostnameVerifiers");
			rootElement.appendChild(hn);
			//Add every hostname verifier errors
			classes = errors.getHnClass();
			if(!classes.isEmpty()) {
				for(int i = 0; i < classes.size(); i++) {
					Element vul = doc.createElement("vulnerability");
					hn.appendChild(vul);
					vul.setAttribute("class", classes.get(i));
					vul.setAttribute("status", errors.getHnVulnerability().get(i));
				}
			}
			classes = errors.getAllowedHnVerifier();
			if(!classes.isEmpty()) {
				for(int i = 0; i < classes.size(); i++) {
					Element vul = doc.createElement("allowAllHostnames");
					hn.appendChild(vul);
					vul.setAttribute("class", classes.get(i));
				}
			}
			Element ssl = doc.createElement("SslHandlerErrors");
			rootElement.appendChild(ssl);
			classes = errors.getSslhandleClass();
			if(!classes.isEmpty()) {
				for(int i = 0; i < classes.size(); i++) {
					Element vul = doc.createElement("vulnerability");
					ssl.appendChild(vul);
					vul.setAttribute("class", classes.get(i));
					vul.setAttribute("status", errors.getSslhandleVulnerability().get(i));
				}
			}
			
			if(scanner != null) {
				
			}
			
			// write the content into xml file
			TransformerFactory transformerFactory = TransformerFactory.newInstance();
			Transformer transformer = transformerFactory.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "4");
			DOMSource source = new DOMSource(doc);
			StreamResult result;
			if(dir == null)
				result = new StreamResult(System.out); 
			else
				result = new StreamResult(new File(dir + File.separatorChar + pk + "_" + version + ".xml"));
			transformer.transform(source, result);
			
		} catch (ParserConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransformerConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransformerException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	/**
	 * Print output in console standard output
	 */
	public static final void printConclusion() {
		scanner = mScanner.getInstance();
		errors = ErrorLists.getInstance();
		System.out.println("Showing results:");
		List<String> classes = errors.getTmClass();
		if(classes.isEmpty())
			System.out.println("TrustManager Vulnerabilities Not Found!\n");
		else {
			System.out.println("TrustManager Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println(classes.get(i)+": ");
				System.out.println("	" + errors.getTmVulnerability().get(i));
			}
			System.out.println();
		}
		classes = errors.getHnClass();
		if(classes.isEmpty()) 
			System.out.println("HostnameVerifier Vulnerabilities Not Found!\n");
		else {
			System.out.println("HostnameVerifier Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i)+": "+ errors.getHnVulnerability().get(i));
			}
			System.out.println();
		}
		classes = errors.getAllowedHnVerifier();
		if(classes.isEmpty()) 
			System.out.println("No ALLOW_ALL_HOSTNAME_VERIFIER found!\n");
		else {
			System.out.println("ALLOW_ALL_HOSTNAME_VERIFIER found in class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i));
			}
			System.out.println();
		}
		classes = errors.getSslhandleClass();
		if(classes.isEmpty())
			System.out.println("SslErrorHandler Vulnerabilities Not Found!\n");
		else {
			System.out.println("SslErrorHandler Vulnerabilities found in Class:");
			for(int i = 0; i < classes.size(); i++) {
				System.out.println("	" + classes.get(i)+": "+ errors.getSslhandleVulnerability().get(i));
			}
			System.out.println();
		}
		if(scanner != null) {
			classes = errors.getMalwareClass();
			if(classes.isEmpty())
				System.out.println("No malware found in APK\n");
			else {
				for(int i = 0; i < classes.size(); i++) {
					System.out.println("	" + classes.get(i)+": "+ errors.getMalware().get(i));
				}
				System.out.println();
			}

		}
	}
	
}
